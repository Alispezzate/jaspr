## ðŸ“Ÿ Rendering Modes

**Jaspr** is a full-stack web framework, meaning it can run both on the server and the client. Depending on what you
want to build you can choose how your app should be built and executed using Jaspr.

- **Static Mode**

  With this mode, Jaspr will generate a fully static site when building your project that you can host at any common website hosting service.
  You can write server-side code to pre-render components and pages at built time, outputting clean html and css to deploy anywhere.
  Additionally, you can set up hydration on the client in order to make your site interactive.

  Read more about [**Static Generation**](/core/static_generation).

- **Server Mode**

  In this mode Jaspr runs and builds a server application that pre-renders your components for each incoming request.
  You can use either Jasprs inbuilt webserver or choose to integrate it into your favorite Dart backend framework.
  Additionally, you can set up hydration on the client in order to make your site interactive.

- **Client Mode**

  If you want, you can skip the server and pre-rendering part of Jaspr completely and use it as a client-side only framework.
  Similar to static mode, you can deploy your built site to any common website hosting service without needing an extra server.

---

Here is also a tabular comparison of the three rendering modes:

|                                               | **static**                        | **server**                         | **client** |
|:----------------------------------------------|-----------------------------------|------------------------------------|------------|
| **Pre-Rendering**                             | Yes (at build time)               | Yes (at request time)              | No         |
| **Client-side rendering** / **Interactivity** | Yes (with [Hydration](/core/modes#hydration)) | Yes (with [Hydration](/core/modes#hydration)) | Yes        |
| **Needs Server**                              | No                                | Yes                                | No         |
| **Deploy to any Webhoster**                   | Yes                               | No                                 | Yes        |
| **Custom backend**                            | No                                | [Yes](/advanced/backend)           | No         |

## ðŸš° Hydration

<Info>
This section is only relevant when using **static** or **server** mode.
</Info>

**Hydration** is the process of making the initial pre-rendered html of a website interactive.

While pre-rendering your components on the server (or at built time with 'static' mode) allows for a fast "first contentful paint"
(when useful content is first displayed to the user), the site is not interactive (e.g. responding to button clicks) until the
client-side rendering is started and event handlers have been attached.

For this to happen seamlessly the initial client-side render has to match the previously pre-rendered html from the server exactly.

> The terms "Pre-Rendering" and "Server-Side-Rendering" can be use interchangeably. "Server" in this context just refers to whatever
> computer performs the initial rendering away from the users browser. This may be an actual webserver running in some datacenter, but
> when using "static" mode this can also be just your computer or e.g. the machine running your ci pipeline.

Hydration is achieved by simply re-executing the same components that have previously pre-rendered the html on the server also
on the client as soon as the browser loads the page.

With Jaspr you can handle hydration in two ways:

- **manually** by writing both server and client entrypoints separately, or
- **automatically** by using the `@client` annotation.

<Info>
It is generally recommended to use automatic hydration.
</Info>

<Tabs defaultValue="auto" values={[
    {label: 'Automatic (Recommended)', value: 'auto'},
    {label: 'Manual', value: 'man'}
]}>
<TabItem value="auto">

For automatic hydration simply use the `@client` annotation on any component.

A component annotated with `@client` will be automatically hydrated on the client after it has been pre-rendered. In principle,
this is like 'resuming' the rendering for a component on the client and picking up where the server-side rendering has left off.

Read more about `@client` components and how to best use them [here](/core/at_client).

</TabItem>
<TabItem value="man">

With manual hydration, you need to create a separate client entrypoint for your app inside the `web/` directory:

```dart title="web/main.dart"
// Client-specific import
import 'package:jaspr/browser.dart';

// Our main component
import 'lib/app.dart';

void main() {
  // Attaches the app component to the <body> tag
  // and hydrates the component / makes it interactive.
  runApp(App(), attachTo: 'body');
}
```

This entrypoint, as any `.dart` file, will then be compiled to javascript as `<filename>.dart.js`.
To load this compiled javascript file on the client, include it as a `<source>` element in your server-rendered html:

```dart title="lib/main.dart"
// Server-specific import
import 'package:jaspr/server.dart';

// Our main component
import 'app.dart';

import 'jaspr_options.dart';

void main() {
  Jaspr.initializeApp(options: defaultJasprOptions);

  runApp(Document(
    head: [
      // Links to the compiled `web/main.dart` file.
      script(src: 'main.dart.js', []),
    ],
    // Pre-renders the [App] component inside the <body> tag
    body: App(),
  ));
}
```

The above setup mounts the `App()` component directly inside the `<body>` element. However, when you are building a more 
content-heavy or mostly static website (static meaning without much user interaction)
you probably don't need to ship your whole app structure to the client, but rather want only certain parts of your
app to be interactive.

You can choose which part(s) of your app you want to hydrate by mounting only that part in your client entrypoint.
Additionally on the client, you can call `runApp()` multiple times to mount different parts of your app separately:

Assuming you have a page layout like this:

```html
<body>
  <header>...</header>
  <main>
    <div id="content">...</div>
    <div id="sidebar">...</div>
  </main>
  <footer>...</footer>
</body>
```

Your client entrypoint could be:

```dart title="web/main.dart"
void main() {
  runApp(Header(), attachTo: 'header');
  runApp(Sidebar(), attachTo: '#sidebar');
  runApp(Content(), attachTo: '#content');
}
```


This will run three apps simultaneously, attached to the specified root elements using css selectors.

The advantage of this approach is that you can leave other parts of your app, e.g. a static footer,
out of the bundled javascript and thereby reducing loading and startup time.

**Be aware** that on the server, you must still construct the complete app layout and and render the
targeted island components manually at the right location.

</TabItem>
</Tabs>


